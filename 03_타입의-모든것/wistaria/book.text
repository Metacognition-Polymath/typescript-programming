
함수

3장에서는 타입스크립트 타입 시스템의 기본 타입, 객체, 배열, 튜플, 열거형 등과 함께 타입스크립트의 타입 추론이란 무엇이며, 타입 할당이 어떻게 이루어지는지 살펴봤다. 이제 타입스크립트에서 가장 중요한 '함수'를 살펴본다. 4장에서는 다음의 내용을 살펴본다.

P

t

타입스크립트에서 함수를 선언하고 실행하는 다양한 방법 | 시그니처 오버로딩 다형적 함수 다형적 타입 별칭

4.1 함수 선언과 호출

자바스크립트에서 함수는 일급(first-class) 객체다. 즉, 객체를 다루듯이 함수를 변수에 할당하거나, 함수를 다른 함수로 전달하거나, 함수에서 함수를 반환하거나, 객체와 프로토타입에 할당하거나, 함수에 프로퍼티를 기록하거나, 함수에 기록된 프로퍼티를 읽는 등의 작업을 할 수 있다. 자바스크립트에서는 함수로 할 수 있는 일이 정말 많은데 덕분에 타입스크립트는 이 모든 것을 자신의 풍부한 타입 시스템에 녹여냈다.

4.1 함수 선언과 호출

P

r

m

.

S

e

g

i

C

55


Programming

다음은 타입스 그립트 함수의 예다 (3장에서 본 함수와 비슷하게 생겼다).

function add(a: number, b: number) { return a + b }

보통 함수 매개변수(앞의 예에서 a와 b)의 타입은 명시적으로 정의한다. 타입스크립트는 항상 함수의 본문에서 사용된 타입들을 추론하지만 특별한 상황을 제외하면 매개변수 타입은 추론하지 않는다. 문맥을 보고 타입을 추론하는 특별한 상황은 “4.1.8 문맥적 타입화”를 참고하자. 반환 타입은 자동으로 추론하지만 원하면 명시할 수 있다.

function add(a: number, b: number): number { return a + b }

이 책에서는 여러분이 함수의 기능을 쉽게 이해할 수 있도록 반환 타입을 명시한다. 하지만 실무에서는 타입스크립트가 반환 타입을 추론하도록 하는 게 보통이다. 타입스크립트가 해줄 수 있는 일을 개발자가 직접 할 필요가 없기 때문이다.

마지막 예에서는 이름을 붙인 함수 문법으로 함수를 선언했는데 자바스크립트와 타입스크립트는 최소 다섯 가지의 함수 선언 방법을 지원한다.

// 이름을 붙인 함수 function greet(name: string) { return 'hello! + name }

// 함수 표현식 let greet2 function (name: string) { return 'hello + name } 1

// 화살표 함수 표현식 let greet3 (name: string) => { return 'hello + name } I

// 단축형 화살표 함수 표현식

4장 함수

56


TypeScript

let greet4 'hello' (name: string) + name

// 함수 생성자 let greet5 = new Function('name', 'return "hello " + name')

타입스크립트는 함수 생성자(안전하지 않으므로 벌떼에 쫓기는 상황이 아니라면 사용하지 않는 편이 좋다)'를 제외한 모든 문법을 안전하게 지원하며, 이 모든 문법은 보통 매개변수 타입의 필수 어노테이션, 반환 타입의 선택형 어노테이션에 적용하는 것과 같은 규칙을 따른다.

간단한 용어 소개매개변수(parameter)는 함수 선언의 일부이며 함수를 실행하는 데 필요한 데이터 조각이다. 정형 매개변수(formal parameter)라고도 부른다.인수(argument)는 함수를 호출할 때 전달해야 하는 데이터 조각이다. 실질 매개변수(actual parameter)라고도 부른다.

타입스크립트에서 함수를 호출할 때 타입 정보는 따로 제공할 필요가 없으며,바로 인수를 전달하면 타입스크립트가 함수의 매개변수와 인수의 타입이 호환되는지 확인한다.

add(1, 2)// 3으로 평가greet('Crystal') // 'hello Crystal'로 평가

물론 인수를 전달하지 않거나 잘못된 타입의 인수를 전달하면 타입스크립트가에러를 발생시킨다.

add(1)add(1, 'a')// 에러 TS2554: 2개의 인수가 필요한데 1개만 전달됨// 에러 TS2345: 'a' 인수 타입은// 'number' 매개변수 타입에 할당할 수 없음

1함수 생성자는 왜 안전하지 않을까? 마지막 예제 코드를 편집기에 입력해보면 타입이 Function이라는 사실을 알수 있다. Function 타입이란 무엇일까? Function은 이름 뒤에 ()를 붙여서 호출할 수 있는 객체로 Function.prototype의 모든 프로토타입 메서드를 포함한다. 하지만 매개변수 타입과 반환 타입을 지정하지 않았으므로 어떤 인수를 건네서도 호출할 수 있으며, 이 과정에서 어떤 문제가 발생하더라도 타입스크립트가 도와줄 수 있는 일이없다.

4.1 함수 선언과 호출

57


Programming

4.1.1 선택적 매개변수와 기본 매개변수

객체와 튜플 타입에서처럼 함수에서도 ?를 이용해 선택적 매개변수를 지정할 수 있다. 함수의 매개변수를 선언할 때 필수 매개변수를 먼저 지정하고 선택적 매개변수를 뒤에 추가한다.

function log(message: string, userId?: string) { let time = new Date().toLocaleTimeString() console.log(time, message, userId || 'Not signed in') }

log('Page loaded') // "12:38:31 PM Page loaded // Not signed in" 출력 // "12:38:31 PM User signed // in da763be" 출력 log('User signed in', 'da763be')

자바스크립트에서처럼 매개변수에 기본값을 지정할 수 있다. 의미상으로는 호출자가 해당 매개변수에 값을 전달하지 않아도 되므로 매개변수를 선택적으로 만드는 것과 같다(선택적 매개변수는 뒤에 와야 하지만 기본 매개변수는 어디에나 추가할 수 있다는 점이 다르다).

예를 들어 log를 다음처럼 다시 구현할 수 있다.

function log(message: string, userId = 'Not signed in') { let time = new Date().toISOString() console.log(time, message, userId) }

log('User clicked on a button', 'da763be') log('User signed out')

userId에 기본값을 제공하므로 선택형 마크(?)와 타입을 지정할 필요가 없어졌다. 영리한 타입스크립트는 기본값으로 매개변수의 타입을 추론할 수 있기 때문이다. 덕분에 코드가 간결해지고 읽기도 쉬워진다. 물론 일반 매개변수에 타입을 지정하듯이 기본 매개변수에도 타입을 명시할 수 있다.

type Context = { appId?: string userId?: string }

4장 함수

58


TypeScript

{}) { function log(message: string, context: Context = let time = new Date().toISOString() console.log(time, message, context.userId) }

보통 실무에서는 선택적 매개변수보다 기본 매개변수를 더 자주 사용하게 된다.

4.1.2 나머지 매개변수

인수를 여러 개 받는 함수라면 그 목록을 배열 형태로 건넬 수도 있다.

function sum(numbers: number[]): number { return numbers.reduce( (total, n) => total + n, 0) }

sum([1, 2, 3]) // 6으로 평가

때로는 (인수의 개수가 고정된) 고정 인자 API가 아니라 (인수의 개수가 달라질 수 있는) 가변 인자 API가 필요할 때도 있다. 전통적으로 자바스크립트는 요술 같은 arguments 객체를 통해 이 기능을 제공했다.

자바스크립트 런타임이 함수에 자동으로 arguments를 정의해 개발자가 함수로 전달한 인수 목록을 할당한다는 점에서 '요술' 같은 일이다. arguments는 일종의 배열(순수한 배열은 아님)이므로 .reduce 같은 내장 기능을 사용하려면 먼저 진짜 배열로 변환해야 한다.

function sumVariadic(): number { return Array .from(arguments) .reduce((total, n) => total + n, 0) }

sumVariadic(1, 2, 3) // 6으로 평가

하지만 arguments에는 한 가지 큰 문제가 있다. 전혀 안전하지 않다는 점이다! 텍스트 편집기에서 total과 n 위로 마우스를 가져가면 그림 4-1과 비슷한 결과를 볼 수 있을 것이다.

4.1 함수 선언과 호출

59


Programming

11 3 14 reduce((total, n) → total * n, 0) function sum() { } return Array .from(arguments) (parameter) n: any reduce((total, n) =total + n, 0) } 6 7 8

그림 4-1 안전하지 않은 arguments

타입스크립트는 n과 total 모두를 any 타입으로 추론했고 sumVariadic을 실제 사용할 때까지는 문제가 드러나지 않는다.

sumVariadic(1, 2, 3)// 에러 TS2554: 0개의 인수가 필요한데 3개의 인수가 제공됨

sumVariadic이 인수를 받지 않도록 선언했으므로 이 함수를 호출하면 타입스크립트의 입장에서는 인수를 받을 수 없다면서 TypeError를 발생시킨다. 그럼 어떻게 안전한 타입의 가변 인수 함수를 만들 수 있을까?

나머지 매개변수(rest parameters)로 이 문제를 해결할 수 있다! 안전하지 않은 arguments를 사용하는 대신 나머지 매개변수를 이용해 sum 함수가 안전하게 임의의 인수를 받게 만든다.

function sumVariadicSafel... numbers: number[]): number { return numbers.reduce( (total, n) => total + n, 0) }

sumVariadicSafe(1, 2, 3) // 6으로 평가

완성했다! 기존 함수와 달라진 부분은 sum 함수의 매개변수 목록에 ... 이 추가되었다는 점뿐이지만 덕분에 타입 안전성을 갖춘 함수가 만들어졌다.

함수는 최대 한 개의 나머지 매개변수를 가질 수 있으며 나머지 매개변수는 함수의 매개변수 목록 맨 마지막에 위치해야 한다. 예를 들어 타입스크립트의 내장 기능인 console.log 선언을 살펴보자(인터페이스는 5장에서 자세히 설명할 것이므로 여기서는 신경 쓰지 말자).

interface Console { log(message?: any, ...optionalParams: any []); void }

4장 함수

60


TypeScript

4.1.3 call, apply, bind

합수를 괄호 ()로 호출하는 방법도 있지만 자바스크립트에서는 두 가지 방법을추가로 제공한다. 앞에서 살펴본 add 함수를 예로 살펴보자.

function add(a: number, b: number): number { return a + b }

add(10, 20)// 30으로 평가add.apply(null, [10, 20]) // 30으로 평가add. call(null, 10, 20) // 30으로 평가add.bind(null, 10, 20) () // 30으로 평가

apply는 함수 안에서 값을 this로 한정(bind)하며(여기에서는 this를 null로한정) 두 번째 인수를 펼쳐 함수에 매개변수로 전달한다. call도 같은 기능을수행하지만 인수를 펼쳐 전달하지 않고 순서대로 전달한다는 점만 다르다.

비슷한 방법으로 bind도 this 인수를 함수의 인수 목록으로 한정한다. 다른점은 bind는 함수를 호출하지 않고 새로운 함수를 반환하는데, 개발자는 ()나.call을 이용해 반환된 함수를 호출하거나 .apply로 아직 한정하지 않은 매개변수를 추가로 전달할 수 있다.

TSC 12H I. strict BindCallApply

코드에서 .call, apply, .bind를 안전하게 사용하려면 tsconfig.json에서 strictBindCallApply를 활성화해야 한다(strict 모드를 이미 활성화했다면 이 옵션은 자동으로활성화됨).

4.1.4 this의 타입

자바스크립트를 사용해보지 않은 독자라면 자바스크립트에서 this 변수가 클래스에 속한 메서드들뿐 아니라 모든 함수에서 정의된다는 사실에 놀랄 것이다. this의 값은 함수를 어떻게 호출했는지에 따라 달라지는데 이는 자바스크립트 코드를 이해하기 어렵게 만드는 고질적인 문제 중 하나다.

4.1 함수 선언과 호출

61


Programming

0 따라서 많은 개발팀은 클래스 메서드를 제외한 다른 모든 곳에서 this 사용을 금한다. TSLint 규칙에서 no-invalid-this를 활성화화면 여러분 코드에 이런 this가 침투하는 일을 방지할 수 있다.

this가 자주 문제를 일으키는 원인은 바로 그 할당 방법에 있다. 메서드를 호출할 때 this는 점 왼쪽의 값을 갖는다는 것이 일반적인 원칙이다. 다음 예를 살펴보자.

let x = { a() { return this } }

x.a() // a()의 바디 안에서 this는 객체 임

하지만 호출이 일어나기 전 어느 시점에서 a를 다시 할당하면 결과가 달라진다!

let a = x.aa() // 이제 a()의 바디 안에서 this는 정의되지 않은 상태임

다음처럼 날짜의 타입을 포매팅하는 유틸리티 함수가 있다고 가정하자.

function fancyDate() { return ${ this.getDate() } /${this.getMonth()}/${ this.getFullYear() } }

그리고 이 API는 (개발자가 함수 매개변수가 무엇인지 배우기도 전인) 아주 오래전에 설계했다고 하자. 이 버전의 fancyDate를 호출하려면 this로 한정할 Date를 제공해야 한다.

fancyDate.call(new Date)// "4/14/2005"로 평가

깜빡하고 Date를 한정하지 않으면 런타임 예외가 발생한다!

fancyDate() // 처리되지 않은 TypeError: this.getDate는 함수가 아님

4장 함수

62


TypeScript -

this의 모든 것을 설명하는 것은 이 책의 범위를 벗어나는 일이니, this의 동작은 예상과 그게 다를 수 있다는 점만 짚고 넘어가자(어떻게 선언하느냐가 아니라 함수를 어떻게 호출하느냐에 영향을 받는다).?

다행히 타입스크립트가 이 문제를 잘 처리해준다. 여러분의 함수에서 this를 사용할 때는 항상 여러분이 기대하는 this 타입을 함수의 첫 번째 매개변수로 선언하자. 그러면 함수 안에 등장하는 모든 this가 여러분이 의도한 this가 됨을 타입스크립트가 보장해준다. 함수 시그니처에 사용한 this는 예약어이므로 다른 매개변수와 완전히 다른 방식으로 처리된다.

function fancyDate(this: Date) { return ${ this.getDate() } /${this.getMonth()}/${ this.getFullYear() }

}

이렇게 수정한 fancyDate를 호출하면 다음과 같은 일이 벌어진다.

fancyDate. call(new Date) // "6/13/2008"으로 평가함 fancyDate()// 01121 TS2684: void E919 'this' 011450|| !// 'Date' 타입의 'this'에 할당할 수 없음

타입스크립트에 많은 정보를 제공한 덕분에 런타임 에러 대신 컴파일 타임에 경고를 시작했다.

0 TSC 9211: nolmplicitThistsconfig.json에서 noImplicitThis를 활성화하면 함수에서 항상 this 타입을 명시적으로 설정하도록 강제할 수 있다. 단, noImplicitThis는 클래스와 객체의 함수에는 this를 지정하라고 강제하지 않는다.

4.1.5 제너레이터 함수

제너레이터 함수(generator function; 줄여서 제너레이터라고 부름)는 여러 개의 값을 생성하는 편리한 기능을 제공한다. 제너레이터 함수를 이용하면 값을 생산하는 속도도 정교하게 조절할 수 있다. 제너레이터 함수는 게으르게 동작

2 this를 더 자세히 알고 싶으면 《You Don't Know JS》 (한빛미디어, 2017)를 참고하자.

4.1 함수 선언과 호출

63


Programming

(즉, 소비자가 요칭해야만 다음 값을 계산)하기 때문에 무한의 목록 생성하기 같은 까다로운 기능을 제공할 수 있다.

제너레이터 함수는 다음처럼 동작한다.

function* createFibonacciGenerator() { O let a = 0 let b = 1 while (true) { yield a; 3 [a, b] = [b, a + b] ④ } }

createFibonacciGenerator()// IterableIterator<number>fibonacciGenerator.next() // {value: 0, done: false}로 평가 fibonacciGenerator.next() // {value: 1, done: false}로 평가 fibonacciGenerator.next() // {value: 1, done: false}로 평가 fibonacciGenerator.next() // {value: 2, done: false}로 평가 fibonacciGenerator.next() // {value: 3, done: false}로 평가 fibonacciGenerator.next() // {value: 5, done: false}로 평가

let fibonacciGenerator =

0 함수명 앞에 붙은 별표(*)는 이 함수가 제너레이터임을 의미한다. 제너레이터를 호출하면 이터러블 반복자가 반환된다.

② 제너레이터는 영구적으로 값을 생성할 수 있다. ③ 제너레이터

는 yield라는 키워드로 값을 방출한다. 소비자가 제너레이터에 다음 값을 요청하면(예: next 호출), yield를 이용해 결과를 소비자에게 보내고, 소비자가 다음 값을 다시 요청하기 전까지는 실행을 중지한다. 이런 방식으로 동작하므로 while(true) 루프가 영원히 실행되다가 비정상 종료되는 상황이 일어나지 않는다.

④ 다음 피보나치 숫자를 계산하기 위해 a에 b를, b에 a + b를 한번에 다시 할당한다.

앞 코드의 createFibonacciGenerator 함수는 IterableIterator를 반환하고, 이 제너레이터에 next를 호출할 때마다 다음 피보나치 값을 계산해서 결과를 방출한다. 타입스크립트가 방출된 값의 타입을 이용해 반복자의 타입을 추론함

4장 함수

64


을 알 수 있다.

TypeScript

다음 예처럼 IterableIterator에서 방출하는 타입을 감싸서 제너레이터의 타입을 명시하는 방법도 있다.

function* createNumbers(): IterableIterator<number { let n = 0 while (1) { yield ntt } }

let numbers = createNumbers()numbers.next() // {value: 0, done: false}로 평가 numbers.next() // {value: 1, done: false}로 평가 numbers.next() // {value: 2, done: false}로 평가

제너레이터 자체도 이야기할 게 많지만, 이 책은 타입스크립트 책이고 자바스크립트 기능을 자세히 다루는 것은 주제에서 벗어나므로 이쯤에서 마무리하겠다. 요약하면 제너레이터는 자바스크립트의 정말 멋진 기능이며 타입스크립트에서도 지원한다는 사실이다. 제너레이터를 더 알고 싶다면 MDN 페이지를 참고하자.

4.1.6 반복자

반복자(iterator)와 제너레이터는 상생관계다. 제너레이터로 값의 스트림을 생성할 수 있고 반복자로 생성된 값을 소비할 수 있기 때문이다. 용어가 조금 어려울 수 있으니 먼저 몇 가지 정의를 확인하자.

이터러블(iterable; 반복할 수 있는)

Symbol.iterator라는 프로퍼티(반복자를 반환하는 함수)를 가진 모든 객체

반복자(iterator)

next라는 메서드(value, done 두 프로퍼티를 가진 객체를 반환)를 정의한 객체

4.1 함수 선언과 호출

3 https://mzl.la/2Uitlk4

65


Programming

가령 createFibonacciGenerator 함수를 호출하면 Symbol.iterator 프로퍼티와 next 메서드를 모두 정의한 값을 얻게 된다. 즉, 이터러블과 반복자 두 가지가 결합된 제너레이터가 반환된다.

Symbol.iterator와 next를 구현하는 객체(또는 클래스)를 만들어 반복자나이터러블을 직접 정의할 수 있다. 다음은 1에서 10까지의 숫자를 반복하는 반복자를 정의하는 예다.

let numbers = { *[Symbol.iterator]() { for (let n = 1; n <= 10; n++){ yield n } } }

반복자 코드를 코드 편집기에 입력한 다음 마우스를 올려놓으면 타입스크립트가 반복자 코드의 타입을 어떻게 추론하는지 확인할 수 있다(그림 4-2).

1 2 3 4 5 6 7 8 let numbers: { [Symbol. iterator](): IterableIterator<num ber>; } let numbers = { *[Symbol. iterator]() { for (let n = 1; n < 10; n+){ yield n } } 9 10 11 12 그림 4-2 직접 반복자 정의하기

결과에서 볼 수 있듯이 numbers는 이터러블이며, 제너레이터 함수 numbers[Symbol.iterator]()를 호출하면 이터러블 반복자가 반환된다.

다음 예에서 보여주듯이 커스텀 반복자뿐 아니라 자바스크립트의 내장 컬렉션 타입(Array, Map, Set, String 등)의 반복자도 정의할 수 있다.

4참고로 Object와 Number는 반복자가 아니다.

4장 함수

66


TypeScript

// for-of로 반복자 반복하기 for (let a of numbers) {// 1,2,3 등 }

// 반복자 스프레드 let al Numbers = [...numbers] // number[]

// 반복자 구조 분해 할당 (destructure) let (one, two, ... rest] = numbers // [number, number, number[0]

반복자도 이 책에서는 자세히 살펴보지 않는다. 반복자와 비동기 반복자를 더 자세히 확인하고 싶다면 MDN'을 참고하자.

TSC 플래그: downlevellteration

타입스크립트를 ES2015 이전 버전의 자바스크립트로 컴파일할 때는 tsconfig.json에서 down levelIteration 플래그로 커스텀 반복자를 활성화할 수 있다. 응용 프로그램의 번들 크기가 커지는 것을 원하지 않으면 downlevelIteration을 비활성화하는 것이 좋다. 예전 환경에서 커스텀 반복자를 지원하려면 많은 코드가 필요하기 때문이다. 예를 들어 이전 numbers 예제는 1KB의 코드를 생성한다(gzipped 상태 기준).

44.1.7 호출 시그니처

지금까지 함수의 매개변수 타입과 반환 타입을 살펴봤다. 이번에는 함수의 전체 타입을 표현하는 방법을 알아보자. 4장의 처음 부분에서 소개했던 sum 함수를 다시 이용한다. 참고로 sum 함수의 코드는 다음과 같다.

function sum(a: number, b: number): number { return a + b }

sum은 무슨 타입일까? sum은 함수이므로 sum은 다음의 타입이라 말할 수 있다.

Function

어느 정도 예상할 수 있겠지만 Function은 사람들이 즐겨 사용하는 타입은 아

5 hups://mzl.la/20Aoylo

4.1 함수 선언과 호출

67


니다. object로 모든 객체를 가리킬 수 있는 것처럼 Function은 모든 함수의 타입을 뜻할 뿐이며 그것이 가리키는 특정 함수와 타입과 관련된 정보는 아무것도 알려주지 않는다.

그러면 sum의 타입을 표현할 수 있는 다른 방법이 있을까? sum은 두 개의number를 인수로 받아 한 개의 number를 반환하는 함수다. 타입스크립트에서는다음과 같이 표현할 수 있다.

(a: number, b: number) => number

이 코드는 타입스크립트의 함수 타입 문법으로, 호출 시그니처(call signature)또는 타입 시그니처(type signature)라 부른다. 이 문법은 화살표 함수와 아주비슷하다는 점을 알 수 있는데 이는 의도된 것이다! 함수에 함수를 인수로 전달하거나 함수에서 다른 함수를 반환하는 경우 이 문법으로 인수나 반환 함수의 타입을 지정할 수 있다.

a, b라는 매개변수명은 문서화 용도일 뿐 함수의 타입과 할당 동작에는 아무 영향도 주지않는다.

함수 호출 시그니처는 타입 수준 코드, 즉 값이 아닌 타입 정보만 포함한다. 이는 함수 호출 시그니처로 매개변수 타입, this 타입("4. 1.4 this의 타입 참고),반환 타입, 나머지 타입, 조건부 타입을 표현할 수 있지만 기본값은 표현할 수없다(기본값은 타입이 아니라 값이므로), 함수 호출 시그니처는 바디를 포함하지 않아 타입스크립트가 타입을 추론할 수 없으므로 반환 타입을 명시해야한다.

타입 수준 코드와 값 수준 코드

정적 타입 프로그래밍에서 사람들은 ‘타입 수준’, ‘값 수준'이라는 용어를 자주 사용하는데이들은 공용 어휘다.

이 책에서 사용하는 타입 수준 코드는 타입과 타입 연산자를 포함하는 코드를 의미한다. 반면 값 수준 코드는 그 밖의 모든 것을 가리킨다. 어떤 코드가 유효한 자바스크립트 코드라면

4장 함수

Programming

68


TypeScript

는 값 수준이고, 유효한 자바스크립트 코드는 아니지만 유효한 타입스크립트 코드라면 타입 수준으로 쉽게 구분할 수 있다. 6

다음 예제를 통해 여러분이 이 개념을 제대로 이해했는지 확인하자(굵은 글씨는 타입 수준이고 나머지는 값 수준이다).

function area(radius: number): number | null { if (radius < 0) { return null } return Math.PI * (radius ** 2) }

let r: number = 3 let a = area(r) if(a !== null) { console.info('result:', a) }

타입 어노테이션과 유니온 타입 연산자(1)는 타입 수준이므로 굵게 표시했고 나머지는 모두 값 수준 용어다.

지금까지 4장에서 살펴본 함수 예제를 다시 살펴보면서 타입 별칭으로 한정할 수 있는 독립 호출 시그니처를 추출해보자.

// greet(name: string) 함수 type Greet = (name: string) => string

// log(message: string, userId?: string) 함수 type Log = (message: string, userId?: string) => void

// sumVariadicSafe(... numbers: number[]): number of type SumVariadicSafe = (... numbers: number[]) => number

예제가 도움이 되었는가? 함수의 호출 시그니처는 구현 코드와 거의 같다. 우연이 아니라 언어 설계상 의도한 결정으로, 이렇게 함으로 호출 시그니처를 쉽

6. 단, 열거형, 클래스, 네임스페이스는 예외다. 열거형은 타입과 값 모두 생성하며 네임스페이스는 값 수준에서 존재한다. 자세한 사항은 부록 C를 참고하자.

4.1 함수 선언과 호출

69


Programming

게 한 수 있다.

오는 시그니기와 구현의 관계를 디 구제적으로 확인하자. 호출 시그니처가구이 있을 때 이떻게 그 시그니기를 만주하는 함수를 구현할 수 있을까? 간단하게 호출 시 그니지를 함수 표현식과 합칠 수 있다. 예를 들어 기존의 Log 함수를새로운 시그니시에 맛게 다시 구현해보자.

type Log = (message: string, userId?: string) => void

let log: Log message, 2 userId = 'Not signed in' 3 let time = new Date().toISOString() console.log(time, message, userId) }

0 함수 표현식 log를 선언하면서 Log 타입임을 명시했다.

② 매개변수의 타입을 다시 지정할 필요는 없다. Log에서 message의 타입을string으로 이미 명시했으므로 다시 지정할 필요는 없다. 타입스크립트가Log를 통해 타입을 추론한다.

userId에 기본값을 지정한다. 호출 시그니처는 값을 포함할 수 없으므로Log에서는 userId의 타입은 지정할 수 있지만 기본값은 지정할 수 없기 때문이다.

Q Log 타입에서 반환 타입을 void로 이미 지정했으므로 반환 타입은 다시 지정할 필요가 없다.

4.1.8 문맥적 타입화

마지막 예는 함수의 매개변수 타입을 명시하지 않아도 되는 첫 사례였다. 이미log의 타입을 Log로 지정했으므로 타입스크립트가 message의 타입을 string으로 추론할 수 있기 때문이다. 이는 문맥적 타입화(contextual typing)라는 타입스크립트 강력한 타입 추론 기능이다.

4장 함수

70


TypeScript -

4장의 앞부분에서 문맥적 타입화를 사용하는 다른 상황(콜백 함수)을 살펴본 바 있다.

times라는 함수를 다음과 같이 선언하자. 이 함수는 콜백 함수 f를 n번 호출하며, 현재의 인덱스를 f의 인수로 전달한다.

function times f: (index: number) => void, n: number { for (let i = 0; i < n; i++) { f(i) } }

times를 호출할 때 함수 선언을 인라인으로 제공하면 인수로 전달하는 함수의 타입을 명시할 필요가 없다.

times (n => console.log(n), 4)

times의 시그니처에서 f의 인수 index를 number로 선언했으므로 타입스크립트는 문맥상 n이 number임을 추론할 수 있다.

f를 인라인으로 선언하지 않으면 타입스크립트는 타입을 추론할 수 없다.

function f(n) { // 에러 TS7006: 매개변수 'n'의 타입은 암묵적으로 'any' 타입이 됨 console.log(n)}

times(f, 4)

4.1.9 오버로드된 함수 타입

이전 절에서 사용한 함수 타입 문법(type Fn = (...) => ...)은 단축형 호출 시그니처(shorthand call signature)다. 이 호출 시그니처를 더욱 명확하게 표현할 수 있다. 다시 Log를 예로 살펴보자.

7 다른 함수의 인수로 전달하는 함수를 '콜백'이라 한다.

4.1 함수 선언과 호출

71


Programming

// 단축형 호출 시그니처 type Log (message: string, userId?: string) => void

// 전체 호출 시그니처 type Log = { (message: string, userId?: string): void }

두 코드는 문법만 조금 다를 뿐 모든 면에서 같다. 여러분은 단축 시그니처를 놔두고 전체 시그니처를 사용하고 싶은가? Log 함수처럼 간단한 상황이라면 단축형을 주로 활용하되 더 복잡한 함수라면 전체 시그니처를 사용하는 것이 좋을 때도 있다.

바로 함수 타입의 오버로딩(overloading)이 좋은 예다. 먼저 함수를 오버로딩한다는 것이 무슨 의미인지 살펴보자.

오버로드된 함수 호출 시그니처가 여러 개인 함수

대부분의 프로그래밍 언어에서 여러 매개변수를 인수로 받아 어떤 타입의 값을 반환하는 함수를 선언한 다음, 이 함수가 요구하는 정확한 매개변수 집합을 건네 함수를 호출하면 항상 똑같은 타입의 반환값을 받게 된다. 자바스크립트는 예외다. 자바스크립트는 동적 언어이므로 어떤 함수를 호출하는 방법이 여러 가지다. 뿐만 아니라 인수 입력 타입에 따라 반환 타입이 달라질 때도

있다!

타입스크립트는 이런 동적 특징을 오버로드된 함수 선언으로 제공하고, 입력 타입에 따라 달라지는 함수의 출력 타입은 정적 타입 시스템으로 각각 제공한다. 이런 언어 기능을 당연하게 여길 수도 있겠지만 사실 타입 시스템의 고급 기능에 속한다!

오버로드된 함수 시그니처를 이용하면 표현력 높은 API를 설계할 수 있다. 예를 들어 Reserve라는 휴가 예약 API를 설계한다고 가정하자. 먼저 타입을 다음처럼 지정할 수 있다(전체 타입 시그니처 사용).

4장 함수

72


TypeScript

type Reserve = { (from: Date, to: Date, destination: string): Reservation }

이제 Reserve의 구현 코드를 보자.

let reserve: Reserve = (from, to, destination) => >{ }

발리로 여행을 가려는 고객이 있다면 from과 to에는 날짜를, destination은 "Bali"로 설정해 reserve API를 이용할 것이다.

다음처럼 편도 여행을 지원하도록 API를 개선할 수도 있다.

type Reserve = { (from: Date, to: Date, destination: string): Reservation (from: Date, destination: string): Reservation }

이 코드를 실행하려 시도하면 타입스크립트가 Reserve를 구현한 코드러를 발생시킨다(그림 4-3).

에서 에

let reserve: Reserve = (from, to, destination) { W... type } (f [ts] Type (from: any, to: any, destination: any) → v (f oid' is not assignable to type 'Reserve'. } let reserve: Reserve let reserve: Reserve = (frorn, to, destination) { }

그림 4-3 조합된 오버로드 시그니처가 존재하지 않을 때 발생하는 TyepError

이 문제는 타입스크립트가 호출 시그니처 오버로딩을 처리하는 방식 때문에 발생한다. 함수 f에 여러 개의 오버로드 시그니처를 선언하면, 호출자 관점에서 f의 타입은 이들 오버로드 시그니처들의 유니온이 된다. 하지만 f를 구현하는 관점에서는 단일한 구현으로 조합된 타입을 나타낼 수 있어야 한다. 이 조합된 시그니처는 자동으로 추론되지 않으므로 f를 구현할 때 직접 선언해야 한

4.1 함수 선언과 호출

73


Programming

다. Reserve 예제에서는 reserve 함수를 다음처럼 바꿀 수 있다.

type Reserve = { (from: Date, to: Date, destination: string): Reservation (from: Date, destination: string): Reservation } 0

let reserve: Reserve = from: Date, toorDestination: Date | string, destination?: string ) => { // ... }

① 오버로드된 함수 시그니처 두 개를 선언한다.

② 구현의 시그니처는 두 개의 오버로드 시그니처를 수동으로 결합한 결과

와 같다(즉, Signature1 | Signature2를 손으로 계산), 결합된 시그니처는 reserve를 호출하는 함수에는 보이지 않는다. 즉, 다음은 소비자 관점의 Reserve 시그니처다.

type Reserve = { (from: Date, to: Date, destination: string): Reservation (from: Date, destination: string): Reservation }

결과적으로 이전에 정의한 결합된 시그니처를 모두 포함하지 않는다.

// 잘못됨! type Reserve = { (from: Date, to: Date, destination: string): Reservation (from: Date, destination: string): Reservation (from: Date, toorDestination: Date | string, destination?: string): Reservation }

두 가지 방식으로 reserve를 호출할 수 있으므로 reserve를 구현할 때 타입스크립트에 reserve가 어떤 방식으로 호출되는지 확인시켜 주어야 한다(더 자세한 사항은 “6.1.5 정제참고).

4장 함수

74


TypeScript

let reserve: Reserve = ( from: Date, toOrDestination: Date | string, destination?: string ) => { if (toOrDestination instanceof Date && destination != undefined) { // 편도 여행 예약 } else if (typeof toOrDestination 'string') { // 왕복 여행 예약 } }

오버로드 시그니처는 구체적으로 유지하자

오버로드된 함수 타입을 선언할 때는 각 오버로드 시그니처(Reserve)를 구현의 시그니처(reserve)에 할당할 수 있어야 한다. 즉, 오버로드를 할당할 수 있는 범위에서 구현의 시그니처를 얼마든지 일반화할 수 있다. 다음 예를 확인해보자.

let reserve: Reserve = ( from: any, toOrDestination: any, destination?: any ) => { // .. }

오버로드를 사용할 때는 함수를 쉽게 구현할 수 있도록 가능한 한 구현의 시그니처를 특정하는 것이 좋다. 이를 앞의 예제에 적용하면 any 대신 Date를, any 대신 Date | String 유니온을 사용할 수 있다.

타입을 좁게(구체적으로) 유지하는 것이 어떻게 주어진 시그니처로 함수를 구현하는 데 도움을 줄까? any 타입으로 받은 매개변수를 Date로 사용하고자 한다면 먼저 그 값이 실제로날짜임을 타입스크립트에 증명해야 한다. 또한 그래야 자동완성 기능의 혜택을 볼 수 있다.

function getMonth(date: any): number | undefined { if (date instanceof Date) { return date.getMonth() } }

4.1 함수 선언과 호출

75


Programming

반면 Date 타입임을 미리 명시해두면 구현 시 일이 줄어든다.

function getMonth(date: Date): number {{ return date.getMonth() }

오버로드는 자연스럽게 브라우저 DOM APJ에서 유용하게 활용된다. 새로운 HTML 요소를 만들 때 사용하는 createElement DOM API를 예로 살펴보자. 이 API는 HTML 태그에 해당하는 문자열을 받아 이 태그 타입의 새 HTML 요소를 반환한다. 타입스크립트는 각 HTML 요소를 내장 타입으로 지원한다. 다음은 타입스크립트가 지원하는 태그의 일부다.

<a> 요소에 대응하는 HTMLAnchorElement

<canvas> 요소에 대응하는 HTMLCanvasElement

• <table> 요소에 대응하는 HTMLTableElement

오버로드된 호출 시그니처는 이 createElement의 동작을 구현하기에 이상적인 메커니즘이다. CreateElement의 타입을 어떻게 지정할 수 있을까? (답을 보기 전에 스스로 풀어보자.)

정답은 다음과 같다.

type CreateElement = { (tag: 'a'): HTMLAnchorElement O (tag: 'canvas') : HTMLCanvasElement (tag: 'table'): HTML TableElement (tag: string) : HTMLElement ② } let createElement: CreateElement = (tag: string): HTMLElement => { 3 // ... }

매개변수는 문자열 리터럴 타입으로 오버로드했다.

② 기타 상황을 추가했다. 사용자가 커스텀 태그명을 전달하거나 타입스크립트의 내장 타입으로 지원하지 않는 최신 태그명을 전달하면 일반적인

4장 함수

76


TypeScript

HITMLElement를 반환한다. 타입스크립트는 선언한 순서대로 오버로드를 해석하므로 오버로드에 지정되지 않은 문자열을 createElement로 전달하면 (예: createElement('foo')) 타입스크립트는 이를 HTMLElement로 분류한다.

③ 구현의 매개변수는 createElement의 오버로드 시그니처가 가질 수 있는 모든 매개변수 타입을 합친 타입, 즉 'a' | 'canvas' | 'table' | string을 지원해야 한다. 세 개의 문자열 리터럴 타입은 모두 string의 서브타입이므로 간단하게 타입 유니온 결과를 string으로 축약할 수 있다.

이 절의 모든 예제에서는 함수 표현식을 오버로드했다. 하지만 함수 선언을 오버로드하고 싶다면 어떻게 해야 할까? 언제나 그렇듯 타입스크립트는 함수 선언을 위해서도 동일한 문법을 제공한다. 그래서 createElement 오버로드 예를 다음처럼 구현할 수도 있다.

function createElement(tag: 'a'): HTMLAnchorElement function createElement(tag: 'canvas'): HTMLCanvasElement function createElement(tag: 'table'): HTMLTableElement function createElement(tag: string): HTMLElement { // ... }

어떤 문법을 사용할지는 오버로딩하려는 함수의 종류(함수 표현식 또는 함수 선언)에 따라 여러분이 선택하면 된다.

전체 타입 시그니처를 함수 호출 방식 오버로딩에만 사용할 수 있는 것은 아니며 함수의 프로퍼티를 만드는 데도 사용할 수 있다. 자바스크립트 함수는 그저 호출할 수 있는 객체이므로 다음처럼 프로퍼티를 할당하여 다음과 같은 일을 할 수 있다.

function warnUser(warning) { if (warnUser.wasCalled) { return }

8. 타입스크립트는 대부분의 리터럴 오버로드를 리터럴이 아닌 오버로드보다 먼저 그리고 순서대로 처리한다. 하지만 모든 개발자가 이 기능에 익숙한 것은 아니므로 이 기능을 이용한다면 다른 개발자가 오버로드 구현이 어떻게 동작하는지 이해하기 어려울 수 있다.

4.1 함수 선언과 호출

77


Programming

warnUser.wasCalled = true alert(warning) } warnUser.wasCalled = false

이렇게 사용자에게 경고를 단 한 번만 보여주는 함수를 만들 수 있다. warnUser의 전체 시그니처를 타입스크립트로 표현해보자.

type WarnUser = {{ (warning: string): void wasCalled: boolean }

warnuser는 호출할 수 있는 함수인 동시에 불 속성인 wasCalled도 가지고 있다.

4.2 다형성

지금까지 구체적인 타입과 구체적인 타입을 사용하는 함수 관련 내용을 살펴봤다. 과연 구체 타입(concrete type)이란 무엇일까? 지금까지 우리가 살펴본모든 타입은 구체 타입이다.

boolean string Date[] •{a: number} | {b: string}

• (numbers: number[]) => number

기대하는 타입을 정확하게 알고 있고, 실제 이 타입이 전달되었는지 확인할 때는 구체 타입이 유용하다. 하지만 때로는 어떤 타입을 사용할지 미리 알 수 없는 상황이 있는데 이런 상황에서는 함수를 특정 타입으로 제한하기 어렵다!

filter라는 함수를 예로 구현하면서 이 내용을 조금 더 생각해보자. 자바스크립트로 filter를 이용해 배열을 반복하면서 정제하는 코드를 다음처럼 구현할 수 있다.

4장 함수

78


TypeScript

function filter(array, f) { let result = 0) for (let i = 0; i < array.length; i++) { let item = array [il if (f(item)) { result.push(item) } } return result }

filter([1, 2, 3, 4], _ => _ < 3) // [1, 2]로 평가

filter 의 전체 타입 시그니처부터 만들어보자. 타입은 일단 unknown으로 지정한다.

type Filter = { (array: unknown, f: unknown) => unknown [] }

이게 number라는 타입이라고 가정해 unknown을 number로 바꾼다.

type Filter = { (array: number[l, f: (item: number) => boolean): number[] }

이 예에서 배열의 타입을 number로 바꾸는 일은 그리 어렵지 않았다. 하지만filter는 범용 함수, 즉 숫자, 문자열, 객체, 배열, 기타 모든 것으로 구성된 배열을 기를 수 있어야 한다. 문자열도 거를 수 있도록 오버로드를 이용해 함수를 각강해보자.

type Filter = { (array: number[], f: (item: number) => boolean): number[] (array: string[l, f: (item: string) => boolean): string[] }

지금까지 벌 문제는 없이 보인다(모든 타입을 오버로드하려면 코드가 좀 지저분재긴 것 같다는 점만 제외하면), 객제 배열도 지원할 수 있을까?

type Filter = {

4.2 다형성

79


Programming

(array: number II, f: (item: number) => boolean): number [] (array: string(), f: (item: string) => boolean): string[] (array: object[], f: (item: object) => boolean): object[] }

얼핏 문제가 없어 보이지만 실제 사용해보면 문제가 발생한다. 시그니처(filter: Filter)대로 filter 함수를 구현하고 실행하면 다음의 결과가 나타난다.

let names = [ { firstName: 'beth' }, { firstName: 'caitlyn' }, { firstName: 'xin' } ]

let result = filter( names, => _. firstName. startsWith('b') ) // 에러 TS2339: 'firstName' 프로퍼티는 'object' 타입에 존재하지 않음

result[0].firstName // 01|21 TS2339: 'firstName' IEEE // 'object' 타입에 존재하지 않음

여기서 타입스크립트가 왜 에러를 발생시키는지 이해할 수 있을 것이다. 타입스크립트에 filter로 숫자, 문자열, 객체의 배열을 전달할 것이라고 선언했다. 그런 다음 객체 배열을 전달했는데 object는 객체의 실제 형태에 대해서는 어떤 정보도 알려주지 않는다는 사실을 기억하자. 따라서 배열에 저장된 객체의 프로퍼티에 접근하려 시도하면 타입스크립트가 에러를 발생시킨다. 배열에 저장된 객체의 형태를 우리가 알려주지 않았기 때문이다.

그럼 어떻게 해야 할까?

제네릭 타입(generic type)을 지원하는 언어를 사용해본 독자라면 “제네릭을 이용하면 해결할 수 있어요!”라고 손을 번쩍 들고 소리 지를 것이다. 좋은 소식은 바로 그것이 정답이라는 것이다(다만 여러분이 방금 크게 지른 소리 때문에 이웃집 아이가 잠에서 깨어났다는 나쁜 소식이 들렸다).

제네릭 타입을 사용해본 적이 없는 독자가 있을 수 있으니 먼저 제네릭이란 무엇인지 정의한 뒤에 filter 함수에 적용해보자.

4장 함수

80


TypeScript

제네릭 타입 매개변수

여러 장소에 타입 수준의 제한을 적용할 때 사용하는 플레이스홀더 타입(placeholdertype). 다형성 타입 매개변수(polymorphic type parameter)라고도 부른다.

다음은 filter 예제에 제네릭 타입 매개변수 T를 적용한 코드다.

type Filter = { <T>(array: T[], f: (item: T) => boolean): T[] }

이 코드는 “filter 함수는 T라는 제네릭 타입 매개변수를 사용한다. 이 타입이 무엇인지 지금은 알 수 없으니 누군가 filter를 호출할 때마다 타입스크립트가 타입을 멋지게 추론해주기 바란다”라는 뜻이다. 타입스크립트는 전달된 array의 타입을 보고 T의 타입을 추론한다. filter를 호출한 시점에 타입스크립트가 T의 타입을 추론해내면 filter에 정의된 모든 T를 추론한 타입으로 대체한다. T는 자리를 맡아둔다는 의미의 '플레이스홀더 타입이며, 타입 검사기가 문맥을 보고 이 플레이스홀더 타입을 실제 타입으로 채우는 것이다. 이처럼 T는 filter의 타입을 매개변수화한다. 이 때문에 T를 제네릭 타입 매개변수라고 부른다.

'제네릭 타입 매개변수'라는 말은 너무 장황하므로 많은 사람은 줄여서 '제네릭 타입' 또는 그냥 '제네릭'이라 부른다. 이 책에서는 이 표현들을 섞어 사용할 것이다.

꺾쇠괄호(<>)로 제네릭 타입 매개변수임을 선언한다(꺾쇠괄호를 제네릭 타입 전용의 type 키워드로 보면 된다). 꺾쇠 기호를 추가하는 위치(꺾쇠 기호를 추가할 수 있는 위치는 한정되어 있다)에 따라 제네릭의 범위가 결정되며 타입스크립트는 지정된 영역에 속하는 모든 제네릭 타입 매개변수 인스턴스가 한 개의 구체 타입으로 한정되도록 보장한다. 이번 예에서도 타입스크립트는 filter를 호출할 때 꺽쇠 괄호의 위치에 기초하여 제네릭 T를 적절한 구체 타입으로 한정한다. 그리고 타입스크립트는 filter에 어떤 인수를 넣어 호출하

4.2 다형성

81


Programming

느냐에 따라 T를 어떤 구체 타입으로 한정할지 정한다. 필요하면 꺾쇠괄호 안에 제네릭 타입 매개변수 여러 개를 콤마로 구분해 선언할 수 있다.

T는 단지 타입 이름으로 T 대신 A, Zebra, l33t 등 원하는 이름은 어떤 것이든 사용할 수있다. 일반적으로 타입 이름은 대문자 T를 시작으로 U, V, W 순으로 필요한 만큼 사용한다.한 행에 아주 많은 제네릭을 사용해야 하거나 제네릭을 복잡한 형태로 사용해야 하는 상황이라면 이런 규칙 대신 Value, WidgetType 같이 설명을 포함하는 이름을 사용할 수있다.

어떤 사람들은 T 대신 A로 시작하는 것을 선호한다. 어떤 프로그래밍 언어 커뮤니티에서는 이어져 내려온 자신들의 방식을 따르기를 선호하기도 한다. 예를 들어 함수형 언어는수학 증명에서 자주 등장하는 그리스 문자 a, B, y를 닮은 A, B, C를 선호하는 반면 객체지향 개발자는 타입(type)을 의미하는 T를 선호한다. 타입스크립트는 두 프로그래밍 스타일을 모두 지원하지만 T 방식을 사용한다.

함수의 매개변수가 함수를 호출할 때 건네진 인수로 매번 다시 한정되듯, T도filter를 호출할 때마다 새로운 타입으로 한정된다.

type Filter = { <T>(array: T[l, f: (item: T) => boolean): T[] } let filter: Filter = (array, f) => // ...

// (a) T는 number로 한정됨 filter([1, 2, 3], => > 2)

// (b) T는 string으로 한정됨 filter(['a', 'b'], L => != 'b')

// (c) T는 {firstName: string}으로 한정됨 let names = [ { firstName: 'beth' }, { firstName: 'caitlyn' }, { firstName: 'xin' } ] filter

(names, firstName. startsWith('b'))

타입스크립트는 전달된 인수의 타입을 이용해 제네릭을 어떤 타입으로 한정할지 추론한다. 타입스크립트가 (a)에서 T를 어떻게 특정 타입으로 한정하는지

4장 함수

82


자세히 살피보자.

TypeScript

1. filter의 타입 시그니처를 통해 array가 타입이 인 요소들로 이루어진 배열임을 알게 된다.

2. 전달된 인수 array [1, 2, 3]을 통해 T는 분명 number라는 사실을 알게 된다.3. 이제 모든 T를 number 타입으로 대치한다. 따라서 매개변수 f: (item:T) => boolean는 f; (item: number) => boolean이 되고 반환 타입 T[]는number[]가 된다.

4. 모든 타입이 할당 조건을 만족하는지, 전달받은 함수 f를 새로 추론한 시그니처에 할당할 수 있는지 확인한다.

제네릭은 함수의 기능을 (구체 타입을 사용할 때보다) 더 일반화하여 설명할수 있는 강력한 도구다. 제네릭을 제한 기능(constraint)으로 생각할 수 있다.함수 매개변수를 n: number로 정해 매개변수 n의 값으로는 number 타입만 오도록 제한하듯이 제네릭 T도 T로 한정하는 타입이 무엇이든 모든 T를 같은 타입으로 제한한다.

타입 별칭, 클래스, 인터페이스에서도 제네릭 타입을 사용할 수 있다. 이 책에서 이런 예를 많이 보게 될 것이다. 다른 주제를 살펴보면서 제네릭 관련 내용이 나올 때마다 따로설명할 것이다.가능하면 제네릭을 사용하자. 제네릭은 코드를 일반화하고, 재사용성을 높이고, 간결하게 유지하는 데 도움을 준다.

4.2.1 언제 제네릭 타입이 한정되는가?

제네릭 타입의 선언 위치에 따라 타입의 범위뿐 아니라 타입스크립트가 제네릭 타입을 언제 구체 타입으로 한정하는지도 결정된다. 바로 앞의 예를 다시살펴보자.

type Filter = { <T>(array: T[], f: (item: T) => boolean): T[] }

4.2 다형성

83


Programming

let filter: Filter = // ... (array, f) =>

이 예에서는 <T>를 호출 시그니처의 일부로(시그니처의 여는 괄호 바로 앞에)선언했으므로 타입스크립트는 Filter 타입의 함수를 실제 호출할 때 구체 타입을 T로 한정한다.

이와 달리 T의 범위를 Filter의 타입 별칭으로 한정하려면 Filter를 사용할 때 타입을 명시적으로 한정하게 해야 한다.

type Filter<T> = { (array: T[], f: (item: T) => boolean): T[] } let filter: Filter = (array, f) => // 에러 TS2314

: 제네릭 타입 'Filter'는

// 한 개의 타입 인수를 요구함

type OtherFilter = Filter // 에러 TS2314: 제네릭 타입 'Filter'는

// 한 개의 타입 인수를 요구함

let filter: Filter<number> =

// ...

(array, f) =>

- type StringFilter Filter <string> let stringFilter: StringFilter = (array, f) => //

보통 타입스크립트는 제네릭 타입을 사용하는 순간에 제네릭과 구체 타입을 한정한다. 제네릭을 사용할 때'란 구체적으로 무슨 뜻일까? 함수에서는 함수를 호출할 때를 의미하고 클래스라면 클래스를 인스턴스화할 때(자세한 사항은 “5.7 다형성” 참고), 타입 별칭과 인터페이스(5.4 인터페이스” 참고)에서는 이들을 사용하거나 구현할 때를 가리킨다.

44.2.2 제네릭을 어디에 선언할 수 있을까?

타입스크립트에서는 호출 시그니처를 정의하는 방법에 따라 제네릭을 추가하는 방법이 정해져 있다.

type Filter = { 0 <T>(array: T[], f: (item: T) => boolean) : T[]

4장 함수

84


TypeScript

} let filter: Filter = // ..

type Filter<T> = { ② (array: T[], f: (item: T) => boolean): T[] } let filter; Filter<number> = // ...

type Filter = <T>(array: T[], f: (item: T) => boolean) => T[③ let filter: Filter = // ...

type Filter<T> = (array: T[l, f: (item: 1) => boolean) => TO let filter: Filter<string> - // ...

function filter<T>(array: T[], f: (item: T) => boolean): T[] { 6 Il .. }

① T의 범위를 개별 시그니처로 한정한 전체 호출 시그니처. T를 한 시그니처 범위로 한정했으므로 타입스크립트는 filter 타입의 함수를 호출할 때 이 시그니처의 T를 구체 타입으로 한정한다. 각각의 filter 호출은 자신만의 T한정 값을 갖는다.

② T의 범위를 모든 시그니처로 한정한 전체 호출 시그니처. T를 Filter 타입의 일부로(특정 시그니처 타입이 아니라) 선언했으므로 타입스크립트는

Filter 타입의 함수를 선언할 때 T를 한정한다.

0과 비슷하지만 전체 시그니처가 아니라 단축 호출 시그니처다. ④ ②와 비슷하지만 전체 시그니처가 아니라 단축 호출 시그니처다. 3

⑤ T를 시그니처 범위로 한정한, 이름을 갖는 함수 호출 시그니처. filter를 호출할 때 T를 타입으로 한정하므로 각 filter 호출은 자신만의 T 한정 값을 갖는다.

두 번째 예로 map 함수를 구현해보자. map은 filter와 비슷하지만 배열에서 항목을 제거하는 대신 매핑 함수를 이용하여 각 항목을 변환한다. 우선 다음 구현에서 시작해보자.

function map(array: unknown [], f: (item: unknown) => unknown): unknown [] { let result = []

4.2 다형성

85


Programming

for (let i = 0; i < array.length; i++) { result[i] = f(array[i]) } return result }

이 시점에서 각 unknown을 어떤 타입으로 바꾸면서 어떻게 범용적인 map을 만들 수 있을지 생각해보자. 얼마나 많은 제네릭이 필요할까? map 함수에서 제네릭을 어떻게 선언하고, 그 범위를 한정할 수 있을까? array, f, 반환값의 타입은 무엇으로 해야 할까??

준비가 되었는가? 먼저 스스로 코드를 구현해 보도록 하자. 여러분은 충분히 할 수 있다!

다음은 정답 코드다.

function map<T, U>(array: T[], f: (item: T) => U): U[] let result = [] for (let i = 0; i < array.length; i++) { result[i] = f(array[i]) } return result }

{

인수 배열 멤버의 타입을 대변하는 T, 반환 배열 멤버 타입을 대변하는 U, 이렇게 두 가지 제네릭 타입이 필요하다. T 타입의 요소를 포함하는 배열을 전달하면 매핑 함수가 T 타입의 값을 가지고 U 타입의 값으로 변환한다. 그리고 최종적으로 U 타입의 항목을 포함하는 배열을 반환한다.

표준 라이브러리의 filter와 map

지금까지 구현한 filter와 map 코드는 타입스크립트에서 제공하는 filter, map 함수와 놀라울 만큼 비슷하다.

interface Array<T> { filter callbackfn: (value: T, index: number, array: T[]) => any, thisArg?: any ): T[]

4장 함수

86


TypeScript

Imap<U>( callbackfn: (value: T, index: number, array: T[]) => U, thisArg?: any ): U 0

}

인터페이스는 아직 배우지 않았지만 이 정의는 filter와 map 함수가 T 타입을 담는 배열을 다룬다고 알려준다. 두 함수 모두 내부에서 callbackfn 함수와 this의 타입을 받는다.

filter는 범위가 Array 인터페이스 전체인 제네릭 T를 사용한다. map도 T를 사용하며, 이

와 더불어 범위가 map 함수로만 제한된 두 번째 제네릭인 U도 사용한다. 즉, 타입스크립트는 배열을 만들 때 T를 구체적 타입으로 한정하고, 이 배열 인스턴스에서 호출되는 filter와 Imap들은 만들어질 때 한정된 구체 타입을 공유하게 된다. 한편 map을 호출하면 기존에 한정한 T를 이용할 수 있을 뿐 아니라 자신만의 U 한정 값도 갖는다.

자바스크립트 표준 라이브러리의 많은 함수, 특히 Array의 프로토타입이 제공하는 함수들은 제네릭이다. 배열은 어떤 타입의 값이든 포함할 수 있으므로 이 타입을 T라 하면 “.push는 인수로 T 타입을 받는다” 라든가 “.map은 T의 배열을 U의 배열로 매핑한다”라고 말할 수 있다.

4.2.3 제네릭 타입 추론

대부분의 상황에서 타입스크립트는 제네릭 타입을 훌륭하게 추론해낸다. 앞에서 구현한 map 함수를 아래처럼 호출하면 타입스크립트는 T를 string으로, U를 boolean으로 추론한다.

function map<T, U>(array: T[l, f: (item: T) => U): U[] } Imap( ['a', 'b', 'c'], // T 타입의 배열 la' // U 타입을 반환하는 함수 )

{

그러나 제네릭도 명시적으로 지정할 수 있다. 제네릭의 타입을 명시할 때는 모든 필요한 제네릭 타입을 명시하거나 반대로 아무것도 명시해서는 안 된다.

4.2 다형성

87


Programming

map<string, boolean>( ['a', 'b', 'c'), 'a' )

Imap<string>( // 에러 TS2558: 두 개의 타입 인수가 필요한데 한 개만 전달됨['a', 'b', 'c'], 'a')

타입스크립트는 추론된 각 제네릭 타입을 명시적으로 한정한 제네릭에 할당할 수 있는지 확인한다. 할당할 수 없으면 에러가 발생한다.

// boolean은 boolean | string에 할당할 수 있으므로 OK map<string, boolean | string>( ['a', 'b', 'c'], 'a' )

Imap<string, number>( ['a', 'b', 'c'), 'a' // 에러 TS2322: 'boolean' 타입은 // 'number' 타입에 할당할 수 없음 ) = 1

타입스크립트는 제네릭 함수로 전달한 인수의 정보를 이용해 제네릭의 구체타입을 추론하므로 때로는 다음과 같은 상황이 벌어질 수 있다.

let promise = new Promise(resolve =>resolve(45))promise. then(result => // {}로 추론함 result * 4// 에러 TS2362: 수학 연산의 왼쪽 연산자는 'any',// 'number', 'bigint', enum 타입 중 하나여야 함)

무슨 일이 일어난 걸까? 왜 타입스크립트는 result를 {}로 추론했을까? 타입스크립트에 충분한 정보를 제공하지 않았기 때문이다. 타입스크립트는 제네릭 함수의 인수에만 의지하여 제네릭 타입을 추론하는데, (인수가 아무것도 없으니 기본적으로) T를 {}로 간주한 것이다!

4장 함수

88


TypeScript

Promise의 제네릭 타입 매개변수를 명시해서 이 문제를 해결할 수 있다.

let promise = new Promise<number>(resolve resolve(45) ) promise. then( result => // number result * 4 )

=>

4.2.4 제네릭 타입 별칭

4장의 앞부분에서 Filter 예제와 함께 제네릭 타입 별칭을 조금 살펴봤다. 3장의 Array와 ReadonlyArray 타입(43쪽의 “읽기 전용 배열과 튜플” 참고)을 기억할지 모르겠지만 이들도 제네릭 타입 별칭이다! 간단한 예를 통해 타입 별칭에서 제네릭을 활용하는 방법을 자세히 살펴보자.

click이나 mousedown 같은 DOM 이벤트를 설명하는 MyEvent 타입을 정의하자.

type MyEvent<T> = { target: T type: string }

타입 별칭에서는 타입 별칭명과 할당 기호(=) 사이에만 제네릭 타입을 선언할 수 있다.

MyEvent의 target 프로퍼티는 <button />, <div /> 등 이벤트가 발생한 요소를 가리킨다. 예를 들어 버튼 이벤트는 다음처럼 표현할 수 있다.

type ButtonEvent = MyEvent<HTMLButtonElement>

MyEvent 같은 제네릭 타입을 사용할 때는 타입이 자동으로 추론되지 않으므로 타입 매개변수를 명시적으로 한정해야 한다.

let myEvent: Event<HTMLButtonElement | null> = { target: document.querySelector('#myButton'), type: 'click' }

4.2 다형성

89


Programming

MyEvent로 TimedEvent 같은 다른 타입을 만들 수 있다. 이렇게 정의하면 타입스크립트는 TimedEvent의 제네릭 T로 한정할 때 이를 MyEvent에도 적용한다.

type TimedEvent<T> = { event: MyEvent<T> from: Date to: Date }

제네릭 타입 별칭을 함수 시그니처에도 사용할 수 있다. 타입스크립트는 구체타입 T로 한정하면서 동시에 MyEvent에도 적용한다.

function triggerEvent<T>(event: MyEvent<T>): void { }

triggerEvent({ // TE Element | null target: document.querySelector('#myButton'), type: 'mouseover! })

이제 어떤 일이 일어나는지 단계별로 살펴보자.

1. 객체에 triggerEvent를 호출한다.

2. 타입

스크립트는 함수의 시그니처 정보를 이용해 전달한 인수가 MyEvent<T>타입이어야 함을 파악한다. 또한 MyEvent<T>를 {target: T, type: string}으로 정의했다는 사실도 인지한다.

스크립트는 호출자가 전달한 객체의 target 필드가 document.query Selector('myButton')이라는 사실을 파악한다. 즉, T의 타입은 document.querySelector('#myButton') o document.querySelector('#myButton'). Element | null 타입이다. 따라서 T는 Element | null 타입으로 한정된다. 4. 타입스크립트는 모든 T를 Element | null로 대체한다.

3. 타입

5. 타입스크립트는 모든 타입이 할당성을 만족하는지 확인한다. 이렇게 타입 확인이 이루어진다.

4장 함수

90


TypeScript

4.2.5 한정된 다형성

이번에는 이진 트리 예제를 사용한다. 이진 트리를 잘 모르더라도 걱정할 것 없다. 기본적으로 이진 트리의 특징은 다음과 같다.

이진 트리는 자료구조다.이진 트리는 노드를 갖는다.노드는 값을 가지며 최대 두 개의 자식 노드를 가리킬 수 있다.노드는 잎 노드(leaf node; 자식이 없음) 또는 내부 노드(inner node; 적어도 한 개의자식을 가짐) 둘 중 하나의 타입을 갖는다.

"T는 어떤 제네릭 타입이야. 그리고 이것은 T와 같은 타입이어야 해”라는 말로는 표현할 수 없는 상황이 많다. 때로는 'U타입은 적어도 T 타입을 포함하는 기능이 필요하다. 이런 상황을 'U가 T의 상한 한계(upper bound)'라고 설명한다.이런 기능이 왜 필요할까? 다음과 같은 세 종류의 노드를 갖는 이진 트리를

구현한다고 해보자.

1. 일반 TreeNode

2. 자식을 갖지 않는 TreeNode인 LeafNode3. 자식을 갖는 TreeNode인 InnerNode

먼저 각 노드의 타입을 선언한다.

type TreeNode = { value: string } type LeafNode = TreeNode & { isLeaf: true } type InnerNode = TreeNode & { children: [TreeNode] | [TreeNode, TreeNode] }

TreeNode는 value라는 한 개의 프로퍼티만 갖는 객체라고 정의했다. LeafNode타입은 TreeNode가 갖는 모든 프로퍼티뿐 아니라 값이 항상 true인 isLeaf 프로퍼티를 추가로 포함한다. InnerNode도 TreeNode의 모든 프로퍼티를 포함하

4.2 다형성

91


Programming

며 한 개나 두 개의 자식을 가리킬 수 있는 children 프로퍼티를 추가로 포함한다.

다음으로 TreeNode를 인수로 받아 value에 매핑 함수를 적용해 새로운 TreeNode를 반환하는 mapNode 함수를 구현해보자. 다음처럼 사용할 수 있는 map Node 함수가 필요하다고 해보자.

let a: TreeNode = {value: 'a'} let b: LeafNode = {value: 'b', isLeaf: true} let c: InnerNode = {value: 'c', children: [b]} =

let al = mapNode(a, let b1 = mapNode(b, let cl = mapNode(c, => _.toUpperCase()) // TreeNode => _.toUpperCase()) // LeafNode => _.toUppercase()) // InnerNode

잠시 멈춰서 TreeNode의 서브타입을 인수로 받아 같은 서브타입을 반환하는 ImapNode 함수를 구현할 수 있을지 생각해보자. LeafNode를 전달하면 LeafNode가 반환되고, InnerNode를 전달하면 InnerNode가 반환되며, TreeNode를 전달하면 TreeNode가 반환될 것이다. 해답을 보기 전에 스스로 생각해보자. 방법을 찾았는가?

이제 답을 확인해보자.

function mapNode<t extends TreeNode>( O node: T, f: (value: string) => string ): T{③ return { ...node, value: f(node.value) } }

o mapNode는 한 개의 제네릭 타입 매개변수 T를 정의하는 함수다. T의 상한 경기는 TreeNode다. 즉, T는 TreeNode이거나 아니면 TreeNode의 서브타입이다.

② mapNode는 두 개의 매개변수를 받는데 첫 번째 매개변수는 T 타입의 노드다. 0에서 노드는 extends TreeNode라고 했으므로 (빈 객체 {}, null,

4장 함수

92


TypeScript

TreeNode 배열 등의) TreeNode가 아닌 다른 것을 인수로 전달하면 바로 꼬불거리는 빨간 밑줄이 나타난다. node는 TreeNode이거나 TreeNode의 서브타입이어야 한다.

③ mapNode는 타입이 T인 값을 반환한다. T는 TreeNode이거나 TreeNode의 하위 타입임을 기억하자.

그렇다면 왜 T를 이런 방식으로 선언할까?

• extends TreeNode를 생략하고 T 타입을 그저 라고만 쓰면 (특정 타입과 연결되지 않은) mapNode가 컴파일 타임 에러를 던질 것이다. T 타입에 상한 경계가 없으므로 node.value를 읽는 행위가 안전하지 않기 때문이다(예를 들어 숫자가 건네질 수도 있다).

T를 아예 사용하지 않고 mapNode를 (node: TreeNode, f: (value: string)string) => TreeNode처럼 선언하면 매핑되면서 타입 정보가 날아가서 al, b1, C1이 모두 TreeNode가 된다. =>

T extends TreeNode라고 표현함으로써 매핑한 이후에도 입력 노드가 특정 타입(TreeNode, LeafNode, InnerNode)이라는 정보를 보존할 수 있다.

여러 제한을 적용한 한정된 다형성

바로 앞의 예에서는 T는 적어도 TreeNode 여야 한다는 타입 제한을 하나 추가했다. 그렇다면 여러 개를 추가하려면 어떻게 해야 할까?

단순히 인터섹션(&)으로 제한들을 이어 붙이면 된다.

type HasSides = { numberOfSides: number } type SidesHaveLength = { sideLength: number }

function logPerimeter< 0 Shape extends HasSides & SidesHaveLength >(s: Shape): Shape { 3 console.log(s. numberOfSides * s.sideLength) returns }

4.2 다형성

93


Programming

- type Square HasSides & SidesHaveLength let square: Square = { numberOfSides: 4, sideLength: 3} logPerimeter(square) // 정사각형, "12" 기록

logPerimeter는 Shape 타입의 인자 s 한 개를 인수로 받는

함수다. ② Shape는 Hassides 타입과 SidesHaveLength 타입을 상속받는 제네릭 타입이

다. 즉, Shape는 적어도 길이(length)를 갖는 변(side)들로 이루어진다. ③ logPerimeter는 인수와 타입이 같은 값을 반환한다.

한정된 다형성으로 인수의 개수 정의하기

가변 인수 함수(임의의 개수의 인수를 받는 함수)에서도 한정된 다형성을 사용할 수 있다. 예를 들어 자바스크립트의 내장 call 함수를 직접 구현해보자(call은 함수 하나와 임의 개수의 인수를 받아서 이 인수들을 함수에 건네 호출하는 함수다). 이 함수를 다음 코드처럼 정의하고 사용할 수 있다. 여기서 unknown 타입은 뒤에서 적절한 타입으로 채워 넣을 것이다.

function call( f: (...args: unknown []) => unknown, ...args: unknown [] ): unknown { return f(...args) }

function fill(length: number, value: string): string[] { return Array. from({ length }, () => value) }

call(fill, 10, 'a') // 'a' 10개를 갖는 배열로 평가

이제 unknown을 채워보자. 우리가 표현하려는 제한은 다음

과 같다.

f는 T 타입의 인수를 몇 개 받아서 R 타입을 반환하는 함수다. 인수가 몇 개인지는 미리 알 수 없다.

• call은 f 한 개와 T 몇 개를 인수로 받으며 인수로 받은 들을 f가 다시 인수

9구현이 너무 복잡해지지 않도록 this는 call 함수에 포함하지 않았다.

4장 함수

94


TypeScript

로 받는다. 마찬가지로 인수가 몇 개인지 미리 알 수 없다.• call은 f의 반환 타입과 같은 R 타입을 반환한다.

따라서 인수 배열 타입 T와 임의의 반환 값 R, 이렇게 두 가지의 타입 매개변수가 필요하다. 이 두 타입을 채워보자.

function call<T extends unknown[], R>( 0 f: (...args: T) => R, ② ...args: TG ): R { ④ return f(...args) }

이 코드는 정확히 어떻게 동작할까? 한 단계씩 살펴보자.

call은 가변 인수 함수로 T와 R 두 개의 타입 매개변수를 받는다. T는unknown []의 서브타입, 즉 어떤 타입의 배열 또는 튜플이다.

② call의 첫 번째 인수는 함수 f다. f 또한 가변 인수 함수로, args와 같은 타입

3의 인수를 받는다. 따라서 args의 타입이 무엇이든 f 인수의 타입도 똑같다.f 함수 외에도, call은 임의의 개수의 매개변수 ...args를 추가로 받는다.args는 나머지 매개변수, 즉 임의의 개수의 인수를 받을 수 있는 매개변수다. args의 타입은 T이며 T는 배열 타입이어야 하므로(실제로 T가 배열 타입을 상속받는다고 지정하지 않으면 타입스크립트는 에러를 발생시킨다)타입스크립트는 args용으로 전달한 인수를 보고 T에 걸맞은 튜플 타입을추론한다.

④ call은 R 타입(f의 반환 타입으로 한정됨)의 값을 반환한다.

이제 call을 호출하면 타입스크립트는 반환 타입이 무엇인지 알 수 있고, 인수의 개수가 잘못되었다면 에러를 발생시킨다.

let let

a =call(fill, 10, 'a') // string[]b = call(fill, 10)// 에러 TS2554: 3개의 인수가 필요하지만// 2개가 전달됨에러 TS2554: 3개의 인수가 필요하지만// 4개가 전달됨

let c =call(fill, 10, 'a', 'z') //

4.2 다형성

95


Programming

0. 4. 1 튜플의 타입 추론 개선'에서 타입스크립트가 나머지 매개변수의 튜플타입을 추론하는 방식의 이점을 취해 튜플의 타입을 더 잘 추론할 수 있도록 이와 비슷한 기법을 이용한다.

4.2.6 제네릭 타입 기본값

함수 매개변수에 기본값을 설정할 수 있듯이 제네릭 타입 매개변수에도 기본 타입을 지정할 있다. 예를 들어 4.2.4 제네릭 타입 별칭”에서 소개한 MyEvent를 다시 확인하자. 그때 다음처럼 type을 이용하여 DOM 이벤트를 모델링했다.

type MyEvent<T> = { target: T type: string }

새 이벤트를 만들려면 제네릭 타입을 MyEvent로 명시적으로 한정하여 이벤트가 발생한 HTML 요소를 정확하게 가리켜야 한다.

let buttonEvent: MyEvent<HTMLButtonElement> = { target: myButton, type: string }

특정 요소 타입을 알 수 없는 때를 대비해 MyEvent의 제네릭 타입에 기본값을 추가할 수 있다.

type MyEvent<T = HTMLElement> = { target: T type: string }

이번에는 4장에서 배운 내용을 적용해 T가 HTML 요소로 한정되도록 T에 경계를 추가해보자.

type MyEvent<T extends HTMLElement = HTMLElement> = { target: T

4장 함수

96


TypeScript -

type: string }

이제 특정 HTML 요소 타입에 종속되지 않은 이벤트도 쉽게 만들 수 있다. 이 이벤트를 만들 때는 MyEvent의 T를 HTMLElement에 수동으로 한정하지 않아도 된다.

- { let myEvent: MyEvent target: myElement, type: string }

함수의 선택적 매개변수처럼 기본 타입을 갖는 제네릭은 반드시 기본 타입을 갖지 않는 제네릭의 뒤에 위치해야 한다.

// 좋음 type MyEvent2< Type extends string, Target extends HTMLElement = HTMLElement, > = { target: Target type: Type }

// 안 좋음 type MyEvent3<

Target extends HTMLElement = HTMLElement, Type extends string // 에러 TS2706: 필수 타입 매개변수는

// 선택적 타입 매개변수 뒤에 올 수 없음> = {

target: Target

type: Type }

4.3 타입 주도 개발

강력한 타입 시스템은 큰 힘을 안겨준다. 그래서 타입스크립트로 코드를 구현할 때 타입을 추종하는 자신을 발견하게 될 것이다. 사람들은 이를 타입 주도 개발이라 부른다.

4.3 타입 주도 개발

97


Programming

타입 주도 개발(type-driven development)

타입 시그니처를 먼저 정하고 값을 나중에 채우는 프로그래밍 방식

표현식이 수용할 수 있는 값의 타입을 제한하는 것이 정적 타입 시스템의 핵심이다. 표현력이 더 풍부한 타입 시스템일수록 표현식 안의 값을 더 잘 설명할 수 있다. 표현력이 높은 타입 시스템을 함수에 적용하면 함수 타입 시그니처를 통해 함수에 관하여 원하는 거의 모든 정보를 얻을 수 있다.

이번 장의 앞에서 소개한 map 함수의 타입 시그니처를 살펴

function map<T, U>(array: T[], f: (item: T) => U): U[] { // ... }

보자.

이전에 map을 전혀 본 적이 없더라도 이 시그니처를 보고 map이 어떤 동작을 하는지 어느 정도는 감을 잡을 수 있을 것이다. map 함수는 T 배열, 그리고 T를 U로 매핑하는 함수를 인수로 받아 U 배열을 반환한다. 함수의 구현을 전혀 확인하지 않고도 이 정보를 알 수 있었다는 사실에 주목하자!'이

타입스크립트 프로그램을 구현할 때는 먼저 함수의 타입 시그니처를 정의한 다음(즉, 타입이 이끈다) 구현을 추가한다. 구현을 시작하기 전에 프로그램을 타입 수준에서 구상해보면 모든 것이 이치에 맞는지를 상위 수준에서 확인할 수 있다.

하지만 이 책은 지금까지 그 반대로 해왔다. 다시 말해, 먼저 구현한 다음 타입을 연역했다. 자, 타입스크립트로 함수의 타입을 정의하고 구현하는 방법을 배웠으니 다음 장부터는 타입을 먼저 정의하고 세부 사항은 나중에 채우는 전략을 이용하겠다.

10 개발자가 정의한 시그니저로부터 함수 바디를 자동으로 구현해주는 능력을 갖춘 해소 기능(constraint solver)을 기본으로 내장한 프로그래밍 인어도 있나 (예: 하스켈(Haskell)과 유사한 언이인 이드리스(Idris)).

4장 함수

98


TypeScript -

4.4 마치며,

4장에서는 함수를 선언하고 호출하는 방법과 매개변수의 타입을 지정하는 방법을 배웠고, 매개변수 기본값, 나머지 매개변수, 제너레이터 함수 등 자바스크립트 함수의 일반적인 기능과 타입스크립트의 반복자 등을 살펴봤다. 함수의 호출 시그니처와 구현의 차이를 확인했고, 문맥적 타입화란 무엇인지와 함수를 오버로드하는 다양한 방법도 배웠다. 마지막으로 함수의 다형성과 타입 별칭을 자세히 살펴봤다. 이 기능이 얼마나 유용한지, 제네릭 타입은 어디에 선언할 수 있고 타입스크립트는 제네릭 타입을 어떻게 추론하는지, 그리고 제네릭 타입에 한계와 기본값을 설정하고 추가하는 방법도 배웠다. 4.3 타입 주도 개발”에서는 타입 주도 개발이 무엇이며 새로 배운 함수 타입 관련 지식을 타입 주도 개발에 어떻게 접목할 수 있는지도 살펴봤다.

연습 문제

1. 타입스크립트는 함수 타입 시그니처에서 어떤 부분을 추론하는가? 매개변수 타입, 반환 타입 또는 두 가지 모두?

2. 자바스크립트의 arguments 객체는 타입 안전성을 제공하는가? 그렇지 않다.면 무엇으로 대체할 수 있을까?

3. 바로 시작되는, 즉 시작 날짜가 바로 지금인 휴가를 예약하는 기능을 구현하려 한다. “4.1.9 오버로드된 함수 타입”에서 소개한 오버로드된 reserve 함수에 명시적 시작 날짜 없이 목적지만 인수로 받는 세 번째 호출 시그니처를 추가하자. 또한 새로 추가한 오버로드된 시그니처를 지원하도록 reserve의 구현도 갱신하자.

4. 어려움 94쪽 “한정된 다형성으로 인수의 개수 정의하기”에서 소개한 call 함수에서 두 번째 인수가 string인 함수여야 정상 동작하도록 구현을 바꿔보자. 이를 제외한 모든 함수는 컴파일 타임에 에러를 발생시켜야 한다.

4.4 마치며

99


Programming

5. 타입 안전성을 지원하는 작은 어서션(assertion) 라이브러리 is를 구현해보자. 먼저 어떤 타입들을 지원할지 구상해보고, 다음처럼 사용할 수 있도록 만들어보자.

// string과 string 비교 is('string', 'otherstring') // false

// boolean과 boolean 비교 is(true, false) // false

// number와 number 비교 is(42, 42) // true

// 서로 다른 두 타입을 비교하려 하면 컴파일 타임 에러가 발생 is(10, 'foo') // 에러 TS2345: "foo" 타입의 인수를 // 'number' 타입의 매개변수에 할당할 수 없음

// [어려움) 임의의 개수의 인수를 전달할 수 있어야 함 is([1], [1, 2], [1, 2, 3]) // false

4장 함수

100