# 10장. Namespaces.Modules

- 프로그램을 구현하면서 다양한 수준으로 캡슐화를 표현할 수 있다
  - 함수
  - 객체, 리스트 같은 자료구조
  - 클래스
  - 패키지 : 클래스 + 유틸리티 등을 묶어서 NPM으로 발행할 수 있음
- 모듈
  - 들어가기 전에
    - 1) 컴파일러(TSC)가 모듈을 해석하는 방법
    - 2) 빌드 시스템(웹팩, Gulp 등)이 모듈을 해석하는 방법
    - 3) 모듈이 실제로 런타임에 응용 프로그램으로 로드되는 방법(script 태그, SystemJS 등)의 차이를 알아야 한다
    - 이 세 가지 일 각각을 별도의 프로그램으로 처리하므로 모듈 관련 내용을 이해하기가 어려웠다
    - 그러다가 CommonJS와 ES2015의 모듈 표준이 나타나고 `세 프로그램(TSC, 웹팩, 런타임로더)`을 연동하기 쉬워졌으며,
    - 이제는 웹팩 같은 강력한 번들러가 내부적으로 알아서 추상화해 실행해주는 단계에 이르렀다

- 10장에서는 타입스크립트는 모듈을 어떻게 해적하고 컴파일하는지 살펴본다
- 빌드 시스템과 런타임 로더가 모듈을 처리하는 방법 => 12장

#### 학습 목표
- 코드에 네임스페이스와 모듈화를 적용하는 다양한 방법
- 코드를 임포트하고 익스포트하는 방법
- 코드의 크기가 커지면서 이런 기법을 확장하는 방법
- 모듈모드 vs. 스크립트 모드
- 선언 합치기의 뜻과 활용 방법

## 10.1 가볍게 살펴보는 자바스크립트 모듈의 역사
- 모듈이 없었다
- 생겼다
- NodeJS는 전부 모듈이다
  - CommonJS
    - 단점
      - require 호출이 동기식
      - 정적분석이 안됨
        - ES2015에서 import / export 가 소개되면서 해결 됨

## 10.2 import, export
- 타입스크립트에서는 ES2015의 import와 export를 사용하는 것이 바람직하다
- 모듈 경로는 파일시스템의 파일명이다

### 10.2.1 동적 임포트
- 응용프로그램이 커지면서 첫 렌더링 시간이 길어짐
  - 특히 프론트엔드에서
  - 백엔드에서도 최상위 수준에서 많은 코드를 임포트한다면 (파일시스템으로 부터 코드를 로딩, 컴파일, 평가하느라) 같은 문제가 발생할 수 있음

- 프론트엔드에서 코드를 분할(splitting)하여 해결할 수 있다
  - 큰 하나의 파일에 모든 코드를 넣지 않고 여러개의 자바스크립트 파일로 나누어 저장하는 방법
  - 병렬로 로딩할 수 있으므로 큰 네트워크 요청을 더 수월하게 처리할 수 있다
  - 코드가 꼭 필요할 때 로딩하는 게으른 로딩(Lazy loading)으로 응용 프로그램을 조금 더 최적화 할 수 있다
- Lazy loading 사례
  - Moment.js - 사용자의 지역정보를 알아내어 관련된 날짜 패키지만 로딩

```ts
// 동적 임포트 사용 예 1
const locale = await import ('locale_us-en');

// 동적 임포트 사용 예 2
import { locale } from './locales/locale-us';

async function main() {
  const userLocale = await getUserLocale();
  const path = `./locales/locale-${userLocale}`;
  const localeUS: typeof locale = await import(path);
}
```

- import로 코드를 정적으로 가져오는 문장으로 쓰거나, 모듈의 Promise를 반환하는 함수로 이용할 수 있다

- import에는 문자열로 평가되는 표현식이라면 무엇이든 전달할 수 있지만,
  대신 타입 안전성을 잃게 된다.
- 동적 임포트를 안전하게 하려면 다음 두 방법 중 하나를 이용해야 한다.

- 타입안전성, 동적으로 계산된 임포트 두마리 토끼를 잡을 수 있다.

#### tsc 설정
- esnext에서만 동적임포트를 지원함(2022.05.26)
- "target": "es2017" 도 설정해줘야 함

### 10.2.2 CommonJS와 AMD 코드 사용하기

모듈을 default import를 사용하려면
- tsconfig.json의 compilerOptions에서 esModuleInterop: true를 설정하면 된다

```ts
import fs from 'fs'

fs.readFile('some/file.txt')
```

## 결론
- namespaces는 전역으로 합쳐준다
- 하지만 어떤 설정(잘모름)이 없으면 타입에러는 없지만 런타임에서 돌아가진 않는다
- 아직 namespaces가 모듈(import)에 비해 쓸만한 부분을 찾지 못 했다
- enum같은 곳에 namespaces를 이용하면 메서드를 추가할 수 있다
