6.9 마치며

6장에서는 타입스크립트의 타입 시스템에서 제공하는 대부분의 고급 기능, 즉 가변성의 입출력, 흐름 기반 타입 추론, 정제, 타입 넓히기, 종합성, 매핑된 타입과 조건부 타입 등을 살펴봤다. 그리고 타입에 적용할 수 있는 고급 패턴인 이름 기반 타입을 흉내내는 타입 브랜딩, 조건부 타입의 분배 특성을 이용해 타입 수준에서 타입 운용하기, 안전하게 프로토타입 확장하기 등도 배웠다.

모든 것을 이해하지 못했거나 기억하지 못하더라도 큰 문제는 없다. 나중에라도 6장으로 돌아와서 배운 내용을 검토하고 더 안전하게 기능을 구현하는 방법을 참고할 수 있을 것이다.

연습 문제

1. 다음 각 타입 쌍에서 첫 번째 타입을 두 번째 타입에 할당할 수 있는지 정하

6.9 마치며

191

고, 그 이유를 설명해보자. 서브타입과 가변성 관점에서 고민해보고, 확신이 서지 않으면 이 장의 처음 부분에서 설명한 규칙들을 확인하자(그래도 잘 모르겠으면 코드 편집기에 직접 코드를 입력해서 확인해보자!).

a. 177 number

b. number 97 1

Programming

C. string 77 number | string

d. Boolean과 number

e. number[]와 (number | string) []

, (number | string) []과 number[]

g. {a: true}와 {a: boolean}

h. {a: {b: [string]}}과 {a: {b: [number | string]}}

i. (a: number) => string과 (b: number) => string

j. (a: number) => string77 (a: string) string

k. (a: number | string) => string과 (a: string) => string

1. E.X (열거형 enum E {X 'X'}에 정의됨)와 F.X (열거형 enum F {X = 'X'}에 정의됨)=

2. type 0= {a: {b: {c: string}}}라는 객체 타입이 있을 때 keyof O는 무슨 타입을 반환할까? ['a']'b')는 무슨 타입인가?

3. T나 U에 속하지만 둘 다에는 속하지 않는 타입을 구하는 Exclusive<T, U>를 구현하자. 예를 들어 Exclusive<1 | 2 | 3, 2 | 3 | 4>의 결과는 1 | 4다. 타입 검사기가 Exclusive<1 | 2, 2 | 4>를 어떻게 평가하는지 단계별로 서술하자.

4. “6.6.3 확실한 할당 어서션”에서 소개한 예제를 확실한 할당 어서션을 사용하지 않도록 재구현하자.
